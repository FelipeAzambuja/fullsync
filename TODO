
---===[ to 0.7 Tasks ]====-----------------------------------------------------


Clarification
	[X]	What situations can occur, how to handle them best,
	[X] ignore directories ? so we dont depend on the order the
		actions are generated -> no

Actions:
	[X] Unify action model, add logging stream using actions
		Actions can be "Add", "Update", "Delete", "Obsolete",
		"UnexpectedChange" + where it happens
	
ActionList:
	[X] Create some action list which will be a buffer pretty often
	    (or reports to a buffer)

Track local changes:
	[X] buffer the situation of the local filesystem and
		check whether there are changes. if so, be able to:
			count these changes
			show which files changed
		... dont get too complex, we'll use svn/cvs anyway if
		it's a large project...
		-> Source Buffer

Task:
	[X] remove task as it is used now and add it as a container for:
		src, dst, state, actions, chosen action
		so we'll have a taskqueue receiving tasks from the processor and
		sending actions to the action queue

ActionQueue:
	[X] those are getting pretty senseless if we remove src/dst.
		either they get even more abstract, say they have a
		add( Action, Node src, Node dst ) method or they get a task (first)

ProcessorResults:
	[X] we do have two different ways of synchronization. we can have
		a pipeline model  Processor->ActionQueue->Buffer->IO Operations
		or a static model Processor->Task w/ 
		Children->Interaction->AQ->Buff->IO
		
		there should be a clean differenciation between building a tasktree and
		applying actions directly. on the other hand, when building a tasktree
		first we could make synchronization more atomic. (check r/w for all
		files first and start sync afterwards)
		
		no diff, only task tree

Expandability:
	[X] put length and lm into FileAttributes ?

FileSystem:
	[X] Maybe make FileSystem and FileSystemProvider
		then Fs could keep track of all dirs instantiated,
		so there is no way we double-load a dir/file
	
		^we really need that... for example we do not know
		when to close ftp connections atm
		
		we should call the access managing unit "FileSystemSite"
		this also marks the virtual root for our sync purposes
		and could be used to store one buffer file

		what about creating universal Directory and File objects
		and letting them get filled with data and functionallity
		by FileSystemConnections ? 
		
		things that must be dynamic:
			- get file info (size, last mod, perms)
			- get childs of dir
			- mkdir, mkfile, write file, read file, delete
			
		I think the new system is pretty nice
		
	[X]	Impl buffering

Clarification:
	[X] where is / and how to avoid //... use . instead

Clarification:
	[X] Bufferupdate !? when where and how ? State refresh and
		ActionDecider recall after Bufferupdate or is it handled
		within the decider ? (why not letting the ActionDecider call
		the StateDecider on the initial objects?)
		
		the only change that can occur after actiondecider is
		the selection of which action should take place.
		ignore for example should not update the buffer.
		
		so it will be best to say we update buffer after action
		and use buffered and unbuffered data to decide which actions
		are possible. that means the AC needs the statedecider as well.
		
		source buffers will not get touched by actions !?
		
		task getting BufferActions ?

FS/Buffer update:
	[X] buffer layer must keep references
		buffed file: refreshReference -> unbuff = parent.getChild( name )
		
-------------------------------------------------------------------------------

Task/Action Interaction:
	we'll get trouble when changing actions creating
	inconsistency, so dont expect too much here

---===[ 0.7 to 0.8 Tasks ]====-------------------------------------------------
		
Ignore:
	[X] apply filter at filesystem level [NO] and add Node.isFiltered() [YES]
		umpf, but it may change during folder traversal...

FTP passwording
	[X] impl general way of supplying more properties to schemes 
		(?password=... ?) or popup?
	[X] save pw crypted
	
SFTP fingerprint 
	[X] w/o questioning or MB question

Logging:
	[X] Implement logging mechanisms
	[X] put sftp logging outside of main log file
	
Connection:
	[X] disconnect properly 

syncfiles
	[X] gzip them

Logwindow
	[X] show progress of performing actions
	[X] show size of files

Feedback:
	[X]	progress indication for performing actions
	[X] progress indication (or at least what am i doing atm) for check phase

Interface:
	[X] we should consider one gui item as gui controller who gets "general" gui 
		stuff lile closeApplication and show busy cursor. generally "FullSync" should
		not be controlling too many gui items, it's much more the heart of the 
		sync processes. so mainwin should get a fullsync instance... or maybe we
		rename this 'sync-controller' somehow ?

Sheduler:
	[X]	copy sheduler from backup - we use Timer and ProfileManager directly
		(so changes to intervals and stuff are propagated much easier)
	[X] add button to toolbar enable/disable scheduling

Release-critical:
	[ ] include license stuff correctly
	[X] LogWindow should have: global source - destination, filename just once,
		                       explanation on the right side
    [X] backup action decider
    [X] stabilize/test backup action decider
    [X] configurable action decider per profile
    [X] "checking <file>" is taking most of the time when comparing local to local
    	we shouldn't push but poll this status string !
   	[ ] scheduler in profile

---===[ to 0.9 Tasks ]====-------------------------------------------------

Gui:
	[X] realize the gui concept (2004-11-07)
	
Versioning:
	[ ] implement working versioning system


---===[ to 0.10 Tasks ]====------------------------------------------------

---===[ to 1.0 Tasks ]====-------------------------------------------------

Images:
	[X] cache images for different states/actions

Logwindow
	[ ] Show size of copied data
	
Syncprocess encapsulement:
	[ ] beside having access to all the neat classes we can use to 
		do a very custom synchronization process we need to encapsule
		the functionallity offered by the program itself, like:
		  - do full sync
		  - just try
		params:
		  - profile name
		  - gui yes/no
		  - interactive yes/no
		  - verbose yes/no

Feedback:
	[X] After ActionQueue: Action started (this may be multiple ?)
		show "(Task 2130 of 2430) E:\bla -> ftp:// ..."
		-> that will make multithreaded task execution extremely hard
	[ ] cancel in sync phase
	[ ] cancel in execution phase
		actually this is not just a Gui thingy, we need to nicely stop the
		ActionQueue/ExecutionBuffer and flush the sync buffer
	[?] some encapsulement for src and dst files ? [Task?]
		
Interface:
	[ ] investigate why the busy cursor is not shown when above the scrollbar
		or table headers - because the main thread still answers
		
	[X] investigate whether it's possible to give the state image in the logwindow
		a transparent bg (so the green bg color is seen all over the line)
		-> the image is transparent atm, we would need to draw a green bg then
				
Naming:
	[ ] call Processor TaskGenerator ? (or is the ActionDecider the generator?)
	[ ] call ActionQueue TaskExecutor ? (as we don't care about the buffer at all)
	[X] call FullSync Synchronizer ? (encapsuling main sync actions / objects)

Architecture:
	[ ] give ActionQueue or Buffer some kind of input stream ?
	[ ] generally make more stream-like behaviour ?		
		nah, it destroys all means of statistics/feedback

Realtime-Reporting:
	[?] Implement realtime status information updating
	[?] Implement events for certain actions

Sheduler:
	[ ] add column next update
	[ ] update lastUpdate / nextUpdate correctly
	[ ] add some simple stuff to the profile (interval, enabled and errorflag 
		with different levels like minor, major, blocker (could not connect))
	[ ] add groups to profiles (so we can cli fullsync saying schedule group a)
	[ ] access to logfiles
	[ ] show that a profile is currently processed

SB:
	[?] we need to build buffer info from fs as well, so fs orphans are
		detected without having the same file on the other side
		maybe make different buffers / different behaviors as
		destination buffer does not want to know about new files in fs
		(it would delete them ?)
	[ ] added monitor fs, but its still not working correctly (buff src
		does not have a length when adding to buffer, maybe use fs ones)
		furthermore, how should this all work at all, to-ftp will always
		have differences to destination, so we'll need to ignore
		src <-> dst state at all.

Processor:
	[ ] impl new TraveralTypes
		actually we'll need the possibility to say "src didn't change, so
		dst doesn't interest me" (in sync without retrieving file data)

Files:
	[ ] we need to differenciate between case sensitivity. 
		store names toLower in hashtables and search for toLower
		ftp: try checking x permission on . to find out if its a win system
		local: check properties ?
	[ ] ascii/bin
	[ ] we can not handle the multiple actions when a dir changes to file or
		the other way around. we would need to delete the exiting one and
		copy over the new one.

TakeIgnore -> Filter:
	[ ] Ignore takes place immediatly atm, on src and dst resulting
		in absolutely no action, just being ignored from all syncs.
		we should maybe add a special rule whether "ignore" is relevant
		for source, destination or both. this does only affect the 
		ruleset, in detail the takeignoredecider. the action decider
		will either not being asked or get a orphan state.
		-> important is to add a location param to the takeignore 
		   deciders method
		-> but the statedecider will mark them equal :-/
		   Node.isIgnored ?
		   
NoBufferFound Handling:
	[ ] let him choose between:   [destination buffer only]
		  - There is nothing at the destination.
			(don't overwrite, build buffer while copying)
		  - There is something at the destination
			but its not sure its the same as in source.
			(don't ask overwrite)
		  - There is the same version in destination.
			(build buffer from filesystem (and source?))		   
			
Execution:
	[ ] make some controlling unit which will handle profile execution
	[ ] we should make sure profiles are locked while executed and 
		we should show some neat symbol then.
	[ ] make fullsync#performActions more feedback-friendly
	[ ]	make logwindow use fullsync#performActions 

Connections:
	[ ] Sftp seems to pretty instable, it starts throwing exceptions
		named "Failure", when trying to retrieve response headers,
		after a few minutes

Backup:
	[ ] copy to temp, then rename
	[ ] scan whole src, then dst - saves hd jumps

Threading
	[ ] better UI / task differenciation
	[ ] console <-> ui 

Connection:
	[ ] reconnect
	
Dispose:
	[ ]	Dispose all images we draw and all other widgets too
	[ ] dispose tableitems

Logging:
	[ ] verify logging quality
			
Buffer:
	[ ] test largefile handling (filesize > buffersize)
	[ ] optimize largefile handling
	[ ] create multithreaded direct-read delayed-write buffer-access
	[ ] create multithreaded delayed-read delayed-write buffer-access
	[ ] create cyclic buffer-storage
	[ ] create bufferedfile tree on the fly instead of ahead of sync process
	
Rules:
	[ ] use xml for rulefiles
	[ ] create generic rulesfile w/ dirrules
	[ ] copy rule abstraction from backup
	[ ] Merge rules or impl good "Set" mechanizm like syncrules in xml

Optimization:
	[ ]	how to optimize and secure FS-access
	[ ] getChild() - on null create, put this into a method ?
		nope...
	[ ] refresh of fs files
	

-------------------------------------------------------------------------------

make isDir info only valid if existant ?

