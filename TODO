
---===[ to 0.7 Tasks ]====-----------------------------------------------------


Clarification
	[X]	What situations can occur, how to handle them best,
	[X] ignore directories ? so we dont depend on the order the
		actions are generated -> no

Actions:
	[X] Unify action model, add logging stream using actions
		Actions can be "Add", "Update", "Delete", "Obsolete",
		"UnexpectedChange" + where it happens
	
ActionList:
	[X] Create some action list which will be a buffer pretty often
	    (or reports to a buffer)

Track local changes:
	[X] buffer the situation of the local filesystem and
		check whether there are changes. if so, be able to:
			count these changes
			show which files changed
		... dont get too complex, we'll use svn/cvs anyway if
		it's a large project...
		-> Source Buffer

Task:
	[X] remove task as it is used now and add it as a container for:
		src, dst, state, actions, chosen action
		so we'll have a taskqueue receiving tasks from the processor and
		sending actions to the action queue

ActionQueue:
	[X] those are getting pretty senseless if we remove src/dst.
		either they get even more abstract, say they have a
		add( Action, Node src, Node dst ) method or they get a task (first)

ProcessorResults:
	[X] we do have two different ways of synchronization. we can have
		a pipeline model  Processor->ActionQueue->Buffer->IO Operations
		or a static model Processor->Task w/ 
		Children->Interaction->AQ->Buff->IO
		
		there should be a clean differenciation between building a tasktree and
		applying actions directly. on the other hand, when building a tasktree
		first we could make synchronization more atomic. (check r/w for all
		files first and start sync afterwards)
		
		no diff, only task tree

Expandability:
	[X] put length and lm into FileAttributes ?

FileSystem:
	[X] Maybe make FileSystem and FileSystemProvider
		then Fs could keep track of all dirs instantiated,
		so there is no way we double-load a dir/file
	
		^we really need that... for example we do not know
		when to close ftp connections atm
		
		we should call the access managing unit "FileSystemSite"
		this also marks the virtual root for our sync purposes
		and could be used to store one buffer file

		what about creating universal Directory and File objects
		and letting them get filled with data and functionallity
		by FileSystemConnections ? 
		
		things that must be dynamic:
			- get file info (size, last mod, perms)
			- get childs of dir
			- mkdir, mkfile, write file, read file, delete
			
		I think the new system is pretty nice
		
	[X]	Impl buffering

Clarification:
	[X] where is / and how to avoid //... use . instead

Clarification:
	[X] Bufferupdate !? when where and how ? State refresh and
		ActionDecider recall after Bufferupdate or is it handled
		within the decider ? (why not letting the ActionDecider call
		the StateDecider on the initial objects?)
		
		the only change that can occur after actiondecider is
		the selection of which action should take place.
		ignore for example should not update the buffer.
		
		so it will be best to say we update buffer after action
		and use buffered and unbuffered data to decide which actions
		are possible. that means the AC needs the statedecider as well.
		
		source buffers will not get touched by actions !?
		
		task getting BufferActions ?

FS/Buffer update:
	[X] buffer layer must keep references
		buffed file: refreshReference -> unbuff = parent.getChild( name )
		
-------------------------------------------------------------------------------

Task/Action Interaction:
	we'll get trouble when changing actions creating
	inconsistency, so dont expect too much here

---===[ 0.7 to 0.8 Tasks ]====-------------------------------------------------
		
Ignore:
	[X] apply filter at filesystem level [NO] and add Node.isFiltered() [YES]
		umpf, but it may change during folder traversal...

FTP passwording
	[X] impl general way of supplying more properties to schemes 
		(?password=... ?) or popup?
	[X] save pw crypted
	
SFTP fingerprint 
	[X] w/o questioning or MB question

Logging:
	[X] Implement logging mechanisms
	[X] put sftp logging outside of main log file
	
Connection:
	[X] disconnect properly 

syncfiles
	[X] gzip them

Logwindow
	[X] show progress of performing actions
	[X] show size of files

Logwindow
	[ ] Show size of copied data
	
Syncprocess encapsulement:
	[ ] beside having access to all the neat classes we can use to 
		do a very custom synchronization process we need to encapsule
		the functionallity offered by the program itself, like:
		  - do full sync
		  - just try
		params:
		  - profile name
		  - gui yes/no
		  - interactive yes/no
		  - verbose yes/no

Feedback:
	[-] After ActionQueue: Action started (this may be multiple ?)
		show "(Task 2130 of 2430) E:\bla -> ftp:// ..."
		-> that will make multithreaded task execution extremely hard
	[ ] Cancel in sync phase
	[X]	progress indication for performing actions
	[X] progress indication (or at least what am i doing atm) for check phase
	[?] some encapsulement for src and dst files ? [Task?]
	
Interface:
	[ ] we should consider one gui item as gui controller who gets "general" gui 
		stuff lile closeApplication and show busy cursor. generally "FullSync" should
		not be controlling too many gui items, it's much more the heart of the 
		sync processes. so mainwin should get a fullsync instance... or maybe we
		rename this 'sync-controller' somehow ?
				
Processor:
	[ ] impl new TraveralTypes
	
Naming:
	[ ] call Processor TaskGenerator ? (or is the ActionDecider the generator?)
	[ ] call ActionQueue TaskExecutor ? (as we don't care about the buffer at all)

Architecture:
	[ ] give ActionQueue or Buffer some kind of input stream ?
	[ ] generally make more stream-like behaviour ?		
		nah, it destroys all means of statistics/feedback

Realtime-Reporting:
	[?] Implement realtime status information updating
	[?] Implement events for certain actions

Sheduler:
	[X]	copy sheduler from backup - we use Timer and ProfileManager directly
		(so changes to intervals and stuff are propagated much easier)
	[X] add button to toolbar enable/disable scheduling
	[ ] add column next update
	[ ] update lastUpdate / nextUpdate correctly
	[ ] add some simple stuff to the profile (interval, enabled and errorflag 
		with different levels like minor, major, blocker (could not connect))
	[ ] access to logfiles
	[ ] show that a profile is currently processed

SB:
	[?] we need to build buffer info from fs as well, so fs orphans are
		detected without having the same file on the other side
		maybe make different buffers / different behaviors as
		destination buffer does not want to know about new files in fs
		(it would delete them ?)
	[ ] added monitor fs, but its still not working correctly (buff src
		does not have a length when adding to buffer, maybe use fs ones)
		furthermore, how should this all work at all, to-ftp will always
		have differences to destination, so we'll need to ignore
		src <-> dst state at all.

Files:
	[ ] we need to differenciate between case sensitivity. 
		store names toLower in hashtables and search for toLower
		ftp: try checking x permission on . to find out if its a win system
		local: check properties ?
	[ ] ascii/bin

TakeIgnore -> Filter:
	[ ] Ignore takes place immediatly atm, on src and dst resulting
		in absolutely no action, just being ignored from all syncs.
		we should maybe add a special rule whether "ignore" is relevant
		for source, destination or both. this does only affect the 
		ruleset, in detail the takeignoredecider. the action decider
		will either not being asked or get a orphan state.
		-> important is to add a location param to the takeignore 
		   deciders method
		-> but the statedecider will mark them equal :-/
		   Node.isIgnored ?
		   
NoBufferFound Handling:
	[ ] let him choose between:   [destination buffer only]
		  - There is nothing at the destination.
			(don't overwrite, build buffer while copying)
		  - There is something at the destination
			but its not sure its the same as in source.
			(don't ask overwrite)
		  - There is the same version in destination.
			(build buffer from filesystem (and source?))		   
			
Execution:
	[ ] make some controlling unit which will handle profile execution
	[ ] we should make sure profiles are locked while executed and 
		we should show some neat symbol then.
	[ ] make fullsync#performActions more feedback-friendly
	[ ]	make logwindow use fullsync#performActions 

---===[ to 1.0 Tasks ]====-----------------------------------------------------

Backup:
	[ ] copy to temp, then rename
	[ ] scan whole src, then dst - saves hd jumps

Threading
	[ ] better UI / task differenciation
	[ ] console <-> ui 

Connection:
	[ ] reconnect
	
Dispose:
	[ ]	Dispose all images we draw and all other widgets too
	[ ] dispose tableitems

Images:
	[ ] cache images for different states/actions

Logging:
	[ ] verify logging quality
			
Buffer:
	[ ] test largefile handling (filesize > buffersize)
	[ ] optimize largefile handling
	[ ] create multithreaded direct-read delayed-write buffer-access
	[ ] create multithreaded delayed-read delayed-write buffer-access
	[ ] create cyclic buffer-storage
	[ ] create bufferedfile tree on the fly instead of ahead of sync process
	
Rules:
	[ ] use xml for rulefiles
	[ ] create generic rulesfile w/ dirrules
	[ ] copy rule abstraction from backup
	[ ] Merge rules or impl good "Set" mechanizm like syncrules in xml

Optimization:
	[ ]	how to optimize and secure FS-access
	[ ] getChild() - on null create, put this into a method ?
		nope...
	[ ] refresh of fs files
	

-------------------------------------------------------------------------------

make isDir info only valid if existant ?

